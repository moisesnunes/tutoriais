---
title: "O que √© Competitive Programming?"
description: "Este artigo ajuda a todos aqueles que querem come√ßar com Programa√ß√£o Competitiva. O √∫nico pr√©-requisito necess√°rio √© o conhecimento de uma linguagem de programa√ß√£o."
lead: "Este artigo ajuda a todos aqueles que querem come√ßar com Programa√ß√£o Competitiva. O √∫nico pr√©-requisito necess√°rio √© o conhecimento de uma linguagem de programa√ß√£o."
date: 2022-10-12T22:24:19-03:00
lastmod: 2022-10-12T22:24:19-03:00
draft: false
images: []
menu:
  docs:
    parent: ""
    identifier: "competitive-a53944ffb8962b5e7a088ab2bfe85ca1"
weight: 1999
toc: true
---
____

{{< alert icon="üí°" text="Por favor, Recarregue a p√°gina para ver os novos conte√∫dos." />}}

## O que √© Competitive Programming?

A programa√ß√£o competitiva combina dois t√≥picos: o design de algoritmos e a implementa√ß√£o de algoritmos.

__Design de algoritmos__: O cerne da programa√ß√£o competitiva √© inventar algoritmos eficientes que resolvam problemas computacionais bem definidos. O design de algoritmos requer habilidades matem√°ticas e de resolu√ß√£o de problemas. Muitas vezes, uma solu√ß√£o para um problema √© uma combina√ß√£o de m√©todos conhecidos e novos insights. A matem√°tica desempenha um papel importante na programa√ß√£o competitiva. Na verdade, n√£o h√° limites claros entre o design de algoritmos e a matem√°tica.

__Implementa√ß√£o de algoritmos__: Na programa√ß√£o competitiva, as solu√ß√µes dos problemas s√£o avaliadas testando um algoritmo implementado usando um conjunto de casos de teste (test case). Assim, depois de chegar a um algoritmo que resolva o problema, o pr√≥ximo passo √© implement√°-lo corretamente, o que requer boas habilidades de programa√ß√£o. A programa√ß√£o competitiva difere muito da engenharia de software tradicional: os programas s√£o curtos (geralmente no m√°ximo algumas centenas de linhas), devem ser escritos rapidamente e n√£o √© necess√°rio mant√™-los ap√≥s o concurso.

No momento, as linguagens de programa√ß√£o mais populares usadas em concursos s√£o C++, Python e Java. Por exemplo, no Google Code Jam 2019, entre os 4.500 melhores participantes, 71% usaram C++, 21% usaram Python e 8% usaram Java. Muitas pessoas consideram C++ a melhor escolha para um programador competitivo. C++ tem como vantagem ser uma linguagem muito eficiente e sua biblioteca padr√£o cont√©m uma grande cole√ß√£o de estruturas de dados e algoritmos.

## Concursos de programa√ß√£o

__IOI__: The *International Olympiad in Informatics* (Olimp√≠ada Internacional de Inform√°tica) √© um concurso anual de programa√ß√£o para alunos do ensino m√©dio. Cada pa√≠s pode enviar uma equipe de quatro alunos para o concurso. Geralmente h√° cerca de 300 participantes de 80 pa√≠ses. O IOI consiste em dois concursos de cinco horas de dura√ß√£o. Em ambos os concursos, os participantes s√£o convidados a resolver tr√™s dif√≠ceis tarefas de programa√ß√£o. As tarefas s√£o divididas em subtarefas, cada uma com uma pontua√ß√£o atribu√≠da. Enquanto os competidores s√£o divididos em equipes, eles competem como indiv√≠duos.

Os participantes do IOI s√£o selecionados atrav√©s de concursos nacionais. Antes do IOI, muitos concursos regionais s√£o organizados, como a *Baltic Olympiad in Informatics* (BOI), a *Central European Olympiad in Informatics* (CEOI), a *Asia-Pacific Informatics Olympiad* (APIO) e a (OBI) *Olimp√≠ada Brasiliera de Inform√°tica*.

__ICPC__: O *International Collegiate Programming Contest* √© um concurso anual de programa√ß√£o para estudantes universit√°rios. Cada equipe do concurso √© composta por tr√™s alunos e, diferentemente do IOI, os alunos trabalham juntos, e apenas um computador est√° dispon√≠vel para cada equipe.

O ICPC consiste em v√°rias etapas e, finalmente, as melhores equipes s√£o convidadas para as Finais Mundiais. Embora existam dezenas de milhares de participantes no concurso, h√° apenas um pequeno n√∫mero de vagas finais dispon√≠veis, portanto, mesmo avan√ßar para as finais √© uma grande conquista.
Em cada concurso ICPC, as equipes t√™m cinco horas para resolver cerca de dez problemas de algoritmos. Uma solu√ß√£o para problema s√≥ √© aceita se resolver todos os casos de teste.

Durante a competi√ß√£o, os competidores podem ver os resultados de outras equipes, mas na √∫ltima hora o placar fica congelado, n√£o sendo poss√≠vel ver os resultados das √∫ltimas submiss√µes.

__CONCURSOS ONLINE__: H√° tamb√©m muitos concursos online que est√£o abertos para todos. No momento, o site de concursos mais ativo √© o [*Codeforces*](https://codeforces.com/), que organiza concursos semanalmente. Outros sites populares de concursos incluem *AtCoder*, *CodeChef*, *CS Academy*, *HackerRank* e *Topcoder*.

Algumas empresas organizam concursos online com finais onsite. Exemplos de tais concursos s√£o [*Facebook Hacker Cup*](https://www.facebook.com/codingcompetitions/hacker-cup), [*Google Code Jam*](https://codingcompetitions.withgoogle.com/codejam), [*Google Kick Start*](https://codingcompetitions.withgoogle.com/kickstart) e [*Yandex.Algorithm*](https://yandex.com/cup/algorithm/). √â claro que as empresas tamb√©m usam esses concursos para recrutamento: ter um bom desempenho em um concurso √© uma boa maneira de provar suas habilidades em programa√ß√£o.

## Dicas para Praticar

Aprender programa√ß√£o competitiva requer uma grande quantidade de esfor√ßo e trabalho. No entanto, existem muitas maneiras de praticar, e algumas delas s√£o melhores que outras. Ao resolver problemas, deve-se ter em mente que o n√∫mero de problemas resolvidos n√£o √© t√£o importante quanto a qualidade dos problemas. √â tentador selecionar problemas que parecem bons e f√°ceis e resolv√™-los, e pular problemas que parecem dif√≠ceis e tediosos. No entanto, a maneira de realmente melhorar as habilidades √© focar nos problemas dif√≠cies e tediosos.

Outra observa√ß√£o importante √© que a maioria dos problemas de concursos de programa√ß√£o podem ser resolvidos usando algoritmos simples e curtos, mas a parte dif√≠cil √© inventar o algoritmo. A programa√ß√£o competitiva n√£o √© aprender de cor algoritmos complexos e obscuros, mas sim aprender a resolver problemas e maneiras de abordar problemas dif√≠ceis usando ferramentas simples.

Finalmente, algumas pessoas desprezam a implementa√ß√£o de algoritmos: √© divertido projetar algoritmos, mas √© chato implement√°-los. No entanto, a capacidade de implementar algoritmos de forma r√°pida e correta √© um ativo importante, e essa habilidade pode ser praticada. √â uma m√° ideia gastar a maior parte do tempo do concurso escrevendo c√≥digo e encontrando bugs, em vez de pensar em como resolver problemas.

## CSES Problem Set

O [*CSES Problem Set*](https://cses.fi/problemset/list/) fornece uma cole√ß√£o de problemas que podem ser usados para praticar programa√ß√£o competitiva. Os problemas foram organizados em ordem de dificuldade.

Vamos ver como resolver o primeiro problema no conjunto de problemas, chamado *Weird Algorithm*:
____

*Considere um algoritmo que recebe como entrada um inteiro positivo $n$. Se $n$ for par, o algoritmo o divide por dois, e se $n$ for √≠mpar, o algoritmo multiplica por tr√™s e soma um. O algoritmo repete isso, at√© que $n$ seja um. Por exemplo, a sequ√™ncia para $n$ = 3 √© a seguinte:*

$$3 ‚Üí 10 ‚Üí 5 ‚Üí 16 ‚Üí 8 ‚Üí 4 ‚Üí 2 ‚Üí 1$$

Sua tarefa √© simular a execu√ß√£o do algoritmo para um determinado valor de n.

__Input__: A √∫nica linha de entrada cont√©m um inteiro $n$.

__Output__: Print uma linha que contenha todos os valores de $n$ durante o algoritmo.

__Restri√ß√µes__: 

- $1 ‚â§ n ‚â§ 10^6$

__Exemplo__: 

Input: 

3

Output:

3 10 5 16 8 4 2 1
____

Este problema est√° ligado √† famosa [*conjectura de Collatz*](https://pt.wikipedia.org/wiki/Conjectura_de_Collatz) que afirma que o algoritmo acima termina para todo valor de $n$. No entanto, ningu√©m foi capaz de provar isso. Neste problema, por√©m, sabemos que o valor inicial de $n$ ser√° no m√°ximo um milh√£o, o que torna o problema muito mais f√°cil de resolver.

Aqui est√° uma maneira poss√≠vel de resolver o problema em C++:

```c++
#include<iostream>
using namespace std;

int main()
{
  int n;
  c >> n;
  while (true) {
    cout << n << " ";
    if (n == 1) break;
    if (n%2 == 0) n /= 2;
    else n = n*3+1;
  }
  cout << "\n";
}
```
O programa primeiro l√™ o n√∫mero de input $n$, depois simula o algoritmo e faz um print do valor de $n$ ap√≥s cada etapa. √â f√°cil testar se o algoritmo trata corretamente o caso de exemplo $n = 3$ dado na declara√ß√£o do problema.

Agora √© a hora de *enviar* o c√≥digo para o CSES. Em seguida, o c√≥digo ser√° compilado e testado usando um conjunto de casos de teste. Para cada caso de teste, o CSES nos dir√° se nosso c√≥digo passou ou n√£o, e tamb√©m podemos examinar o input, o output esperado e o output produzido pelo nosso c√≥digo.

Ap√≥s testar nosso c√≥digo, o CSES fornece o seguinte relat√≥rio:

![img](./fig-1.png)

Isso significa que nosso programa passou em alguns dos casos de teste (ACCEPTED), √†s vezes era muito lento (TIME LIMIT EXCEEDED) e tamb√©m produzio uma sa√≠da incorreta ((WRONG ANSWER). O que √© bastante surpreendente!

O primeiro caso de teste que falha tem $n = 138367$. Se testarmos nosso c√≥digo localmente usando essa entrada, veremos que o c√≥digo √© realmente lento. Na verdade, nunca termina.

A raz√£o pela qual nosso programa falha √© que $n$ pode se tornar bastante grande durante a simula√ß√£o. Em particular, pode se tornar maior que o limite superior de uma vari√°vel *int*. Para corrigir o problema, basta alterar nosso c√≥digo para que o tipo de $n$ seja *long long*. Ent√£o teremos o resultado desejado:

```c++
#include<iostream>
using namespace std;

int main()
{
  long long n;
  c >> n;
  while (true) {
    cout << n << " ";
    if (n == 1) break;
    if (n%2 == 0) n /= 2;
    else n = n*3+1;
  }
  cout << "\n";
}
```
![img](./fig-2.png)

Como este exemplo mostra, mesmo algoritmos muito simples podem conter bugs sutis. A programa√ß√£o competitiva ensina como escrever algoritmos que realmente funcionam.
